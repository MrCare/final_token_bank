/*
 * @Author: Mr.Car
 * @Date: 2025-07-27 16:55:00
 */
import { useState, useEffect } from 'react';
import { useAccount, useReadContract, useWriteContract, useWaitForTransactionReceipt, useSignTypedData } from 'wagmi';
import { formatUnits, parseUnits } from 'viem';
import { NFTMARKET_ADDRESS, NFTMARKET_ABI, NFT_ADDRESS, NFT_ABI, TOKEN_ADDRESS, TOKEN_ABI } from '@/lib/contracts';
import { useRefreshStore } from '@/lib/store';
import { 
  PageContainer, 
  PageHeader, 
  InfoCard, 
  StatsCard, 
  StatusCard, 
  DataRow,
  ActionButton,
  InputField
} from './ui/base-components';

export function NftMarketNew() {
  const { address, isConnected } = useAccount();
  const [tokenId, setTokenId] = useState('');
  const [price, setPrice] = useState('');
  const [buyTokenId, setBuyTokenId] = useState('');
  const [whitelistSignature, setWhitelistSignature] = useState('');
  const [usePermitBuy, setUsePermitBuy] = useState(false);
  
  const { writeContract, data: hash, error: writeError, isPending: isWritePending } = useWriteContract();
  const { isLoading: isConfirming, isSuccess: isConfirmed } = useWaitForTransactionReceipt({
    hash,
  });

  // Token permit Á≠æÂêç
  const { signTypedData, data: permitSignatureData, isPending: isSigningPermit } = useSignTypedData();

  // Ëé∑Âèñ Token ‰ΩôÈ¢ù
  const { data: tokenBalance, refetch: refetchTokenBalance } = useReadContract({
    address: TOKEN_ADDRESS,
    abi: TOKEN_ABI,
    functionName: 'balanceOf',
    args: address ? [address] : undefined,
  });

  // Ëé∑Âèñ Token ÊéàÊùÉÈ¢ùÂ∫¶
  const { data: tokenAllowance, refetch: refetchTokenAllowance } = useReadContract({
    address: TOKEN_ADDRESS,
    abi: TOKEN_ABI,
    functionName: 'allowance',
    args: address ? [address, NFTMARKET_ADDRESS] : undefined,
  });

  // Ëé∑Âèñ Token nonces (Áî®‰∫é permit)
  const { data: tokenNonces } = useReadContract({
    address: TOKEN_ADDRESS,
    abi: TOKEN_ABI,
    functionName: 'nonces',
    args: address ? [address] : undefined,
  });

  // ËØªÂèñÊåÇÂçï‰ø°ÊÅØ (‰∏äÊû∂Êó∂‰ΩøÁî®)
  const { data: listing, refetch: refetchListing } = useReadContract({
    address: NFTMARKET_ADDRESS,
    abi: NFTMARKET_ABI,
    functionName: 'listings',
    args: tokenId ? [BigInt(tokenId)] : undefined,
  });

  // ËØªÂèñË¥≠‰π∞ NFT ÁöÑÊåÇÂçï‰ø°ÊÅØ
  const { data: buyListing, refetch: refetchBuyListing } = useReadContract({
    address: NFTMARKET_ADDRESS,
    abi: NFTMARKET_ABI,
    functionName: 'listings',
    args: buyTokenId ? [BigInt(buyTokenId)] : undefined,
  });

  // Ê£ÄÊü• NFT ÊéàÊùÉ
  const { data: isApproved, refetch: refetchApproval } = useReadContract({
    address: NFT_ADDRESS,
    abi: NFT_ABI,
    functionName: 'isApprovedForAll',
    args: address ? [address, NFTMARKET_ADDRESS] : undefined,
  });

  // Ê£ÄÊü• NFT Êã•ÊúâËÄÖ (‰∏äÊû∂Êó∂‰ΩøÁî®)
  const { data: nftOwner } = useReadContract({
    address: NFT_ADDRESS,
    abi: NFT_ABI,
    functionName: 'ownerOf',
    args: tokenId ? [BigInt(tokenId)] : undefined,
  });

  const triggerRefresh = useRefreshStore((state) => state.triggerRefresh);

  // ‰∫§ÊòìÁ°ÆËÆ§ÂêéÂà∑Êñ∞Êï∞ÊçÆ
  useEffect(() => {
    if (isConfirmed) {
      refetchListing();
      refetchBuyListing();
      refetchApproval();
      refetchTokenBalance();
      refetchTokenAllowance();
      triggerRefresh();
      console.log('NFT Â∏ÇÂú∫‰∫§ÊòìÂ∑≤Á°ÆËÆ§ÔºåÊï∞ÊçÆÂ∑≤Êõ¥Êñ∞');
    }
  }, [isConfirmed, refetchListing, refetchBuyListing, refetchApproval, refetchTokenBalance, refetchTokenAllowance, triggerRefresh]);

  // ÊéàÊùÉ NFT
  const handleApproveNFT = async () => {
    try {
      await writeContract({
        address: NFT_ADDRESS,
        abi: NFT_ABI,
        functionName: 'setApprovalForAll',
        args: [NFTMARKET_ADDRESS, true],
      });
    } catch (error) {
      console.error('NFTÊéàÊùÉÂ§±Ë¥•:', error);
    }
  };

  // ‰∏äÊû∂ NFT
  const handleListNFT = async () => {
    if (!tokenId || !price) {
      alert('ËØ∑Â°´ÂÜô Token ID Âíå‰ª∑Ê†º');
      return;
    }

    // Ê£ÄÊü•ÊòØÂê¶Êã•ÊúâÊ≠§ NFT
    if (nftOwner && address && nftOwner.toLowerCase() !== address.toLowerCase()) {
      alert('ÊÇ®‰∏çÊã•ÊúâÊ≠§ NFTÔºÅ');
      return;
    }

    try {
      await writeContract({
        address: NFTMARKET_ADDRESS,
        abi: NFTMARKET_ABI,
        functionName: 'listNFT',
        args: [BigInt(tokenId), parseUnits(price, 18)], // 18‰ΩçÂ∞èÊï∞ÁöÑToken
      });

      setTokenId('');
      setPrice('');
    } catch (error: any) {
      console.error('‰∏äÊû∂Â§±Ë¥•:', error);
      alert(`‰∏äÊû∂Â§±Ë¥•: ${error?.message || 'Êú™Áü•ÈîôËØØ'}`);
    }
  };

  // ‰ΩøÁî® permit Ë¥≠‰π∞ NFT (Ëá™Âä®ÁîüÊàê token permit Á≠æÂêç)
  const handlePermitBuy = async () => {
    if (!buyTokenId || !buyListing || !whitelistSignature) {
      alert('ËØ∑Â°´ÂÜôÂÆåÊï¥‰ø°ÊÅØÔºöToken ID ÂíåÁôΩÂêçÂçïÊéàÊùÉÁ≠æÂêç');
      return;
    }

    if (!address || !tokenNonces) {
      alert('Êó†Ê≥ïËé∑ÂèñË¥¶Êà∑‰ø°ÊÅØÊàñ nonce');
      return;
    }

    try {
      // ËÆæÁΩÆ permit ËøáÊúüÊó∂Èó¥ (24Â∞èÊó∂Âêé)
      const deadline = Math.floor(Date.now() / 1000) + 24 * 60 * 60;

      // ÊûÑÂª∫ EIP-712 Á±ªÂûãÂåñÊï∞ÊçÆÁî®‰∫é Token permit
      const domain = {
        name: 'FinalCarToken', // ÈúÄË¶Å‰∏é‰Ω†ÁöÑ Token ÂêàÁ∫¶ÂêçÁß∞ÂåπÈÖç
        version: '1',
        chainId: 31337, // Anvil Êú¨Âú∞Èìæ ID
        verifyingContract: TOKEN_ADDRESS,
      };

      const types = {
        Permit: [
          { name: 'owner', type: 'address' },
          { name: 'spender', type: 'address' },
          { name: 'value', type: 'uint256' },
          { name: 'nonce', type: 'uint256' },
          { name: 'deadline', type: 'uint256' },
        ],
      };

      const message = {
        owner: address,
        spender: NFTMARKET_ADDRESS,
        value: buyListing[1],
        nonce: tokenNonces,
        deadline: BigInt(deadline),
      };

      console.log('üîê ÂºÄÂßãÁ≠æÂêç Token permit...');
      console.log('Domain:', domain);
      console.log('Message:', message);

      // Á≠æÂêç Token permit
      await signTypedData({
        domain,
        types,
        primaryType: 'Permit',
        message,
      });

      // Á≠âÂæÖÁ≠æÂêçÂÆåÊàê
      if (!permitSignatureData) {
        console.log('Á≠âÂæÖÁî®Êà∑Á≠æÂêç...');
        return;
      }

    } catch (error: any) {
      console.error('Á≠æÂêçÂ§±Ë¥•:', error);
      alert(`Á≠æÂêçÂ§±Ë¥•: ${error?.message || 'Êú™Áü•ÈîôËØØ'}`);
    }
  };

  // ÂΩì permit Á≠æÂêçÂÆåÊàêÂêéÔºåÊâßË°åË¥≠‰π∞
  useEffect(() => {
    const executePurchase = async () => {
      if (permitSignatureData && buyTokenId && buyListing && whitelistSignature && address && tokenNonces) {
        try {
          console.log('üöÄ ÊâßË°å permit Ë¥≠‰π∞...');
          
          // Ëß£ÊûêÁ≠æÂêç
          const signature = permitSignatureData.slice(2); // ÁßªÈô§ 0x
          const r = `0x${signature.slice(0, 64)}`;
          const s = `0x${signature.slice(64, 128)}`;
          const v = parseInt(signature.slice(128, 130), 16);
          
          // ÈáçÊñ∞ËÆ°ÁÆó deadline
          const deadline = Math.floor(Date.now() / 1000) + 24 * 60 * 60;

          console.log('üìù Permit ÂèÇÊï∞:');
          console.log('- deadline:', deadline);
          console.log('- v:', v);
          console.log('- r:', r);
          console.log('- s:', s);

          await writeContract({
            address: NFTMARKET_ADDRESS,
            abi: NFTMARKET_ABI,
            functionName: 'permitBuy',
            args: [
              BigInt(buyTokenId), 
              whitelistSignature as `0x${string}`, 
              BigInt(deadline), 
              v, 
              r as `0x${string}`, 
              s as `0x${string}`
            ],
          });

          // Ê∏ÖÁ©∫Ë°®Âçï
          setBuyTokenId('');
          setWhitelistSignature('');

        } catch (error: any) {
          console.error('PermitË¥≠‰π∞Â§±Ë¥•:', error);
          alert(`‰∫§ÊòìÂ§±Ë¥•: ${error?.message || 'Êú™Áü•ÈîôËØØ'}`);
        }
      }
    };

    executePurchase();
  }, [permitSignatureData, buyTokenId, buyListing, whitelistSignature, address, tokenNonces, writeContract]);

  // Áõ¥Êé•Ë¥≠‰π∞ NFT (ÈúÄË¶ÅÈ¢ÑÂÖàÊéàÊùÉ)
  const handleDirectBuy = async () => {
    if (!buyTokenId || !buyListing) {
      alert('ËØ∑ËæìÂÖ•Ë¶ÅË¥≠‰π∞ÁöÑ Token ID');
      return;
    }

    // Ê£ÄÊü• Token ‰ΩôÈ¢ù
    if (tokenBalance && buyListing[1]) {
      if (tokenBalance < buyListing[1]) {
        alert(`Token ‰ΩôÈ¢ù‰∏çË∂≥ÔºÅÈúÄË¶Å ${formatUnits(buyListing[1], 18)} TokenÔºåÂΩìÂâçÊúâ ${formatUnits(tokenBalance, 18)} Token`);
        return;
      }
    }

    // Ê£ÄÊü• Token ÊéàÊùÉ
    if (tokenAllowance && buyListing[1]) {
      if (tokenAllowance < buyListing[1]) {
        alert('ÈúÄË¶ÅÂÖàÊéàÊùÉË∂≥Â§üÁöÑ Token ÁªôÂ∏ÇÂú∫ÂêàÁ∫¶');
        return;
      }
    }

    try {
      await writeContract({
        address: NFTMARKET_ADDRESS,
        abi: NFTMARKET_ABI,
        functionName: 'buyNFT',
        args: [BigInt(buyTokenId)],
      });

      setBuyTokenId('');
    } catch (error: any) {
      console.error('Áõ¥Êé•Ë¥≠‰π∞Â§±Ë¥•:', error);
      alert(`‰∫§ÊòìÂ§±Ë¥•: ${error?.message || 'Êú™Áü•ÈîôËØØ'}`);
    }
  };

  // ÊéàÊùÉ Token
  const handleApproveToken = async () => {
    if (!buyListing) {
      alert('ËØ∑ÂÖàËæìÂÖ•Ë¶ÅË¥≠‰π∞ÁöÑ NFT Token ID');
      return;
    }

    try {
      await writeContract({
        address: TOKEN_ADDRESS,
        abi: TOKEN_ABI,
        functionName: 'approve',
        args: [NFTMARKET_ADDRESS, buyListing[1]],
      });
    } catch (error: any) {
      console.error('Token ÊéàÊùÉÂ§±Ë¥•:', error);
      alert(`Token ÊéàÊùÉÂ§±Ë¥•: ${error?.message || 'Êú™Áü•ÈîôËØØ'}`);
    }
  };

  // Êó†ÈôêÊéàÊùÉ Token
  const handleApproveTokenMax = async () => {
    try {
      const maxUint256 = BigInt('115792089237316195423570985008687907853269984665640564039457584007913129639935');
      await writeContract({
        address: TOKEN_ADDRESS,
        abi: TOKEN_ABI,
        functionName: 'approve',
        args: [NFTMARKET_ADDRESS, maxUint256],
      });
    } catch (error: any) {
      console.error('Token Êó†ÈôêÊéàÊùÉÂ§±Ë¥•:', error);
      alert(`Token ÊéàÊùÉÂ§±Ë¥•: ${error?.message || 'Êú™Áü•ÈîôËØØ'}`);
    }
  };

  if (!isConnected) {
    return (
      <PageContainer gradient="bg-gradient-to-br from-amber-50 via-white to-orange-50">
        <StatusCard
          icon="üîå"
          title="ËØ∑ËøûÊé•Èí±ÂåÖ"
          message="ÈúÄË¶ÅËøûÊé•Èí±ÂåÖÊâçËÉΩ‰ΩøÁî® NFT Â∏ÇÂú∫ÂäüËÉΩ"
          type="warning"
        />
      </PageContainer>
    );
  }

  return (
    <PageContainer gradient="bg-gradient-to-br from-amber-50 via-white to-orange-50">
      <PageHeader
        icon="üè™"
        title="NFT Token Â∏ÇÂú∫"
        subtitle="‰ΩøÁî® Token ‰π∞ÂçñÊÇ®ÁöÑÊï∞Â≠óÊî∂ËóèÂìÅ"
        iconColor="bg-gradient-to-br from-amber-500 to-orange-600"
        titleColor="bg-gradient-to-r from-amber-600 to-orange-600"
      />

      {/* ‰ΩôÈ¢ùÂíåÊéàÊùÉÁä∂ÊÄÅ */}
      <div className="grid grid-cols-1 md:grid-cols-3 gap-6 mb-6">
        <StatsCard
          icon="ü™ô"
          title="Token ‰ΩôÈ¢ù"
          subtitle="Token Balance"
          value={tokenBalance ? formatUnits(tokenBalance, 18) : '0'}
          unit="TOKEN"
          bgColor="bg-gradient-to-br from-green-500 to-emerald-600"
          iconColor="bg-white/20"
        />
        
        <StatsCard
          icon={isApproved ? "‚úÖ" : "‚ö†Ô∏è"}
          title="NFT ÊéàÊùÉ"
          subtitle="NFT Authorization"
          value={isApproved ? "Â∑≤ÊéàÊùÉ" : "Êú™ÊéàÊùÉ"}
          unit=""
          bgColor={isApproved ? "bg-gradient-to-br from-emerald-500 to-green-600" : "bg-gradient-to-br from-amber-500 to-yellow-600"}
          iconColor="bg-white/20"
        />

        <StatsCard
          icon="üîì"
          title="Token ÊéàÊùÉ"
          subtitle="Token Allowance"
          value={tokenAllowance ? formatUnits(tokenAllowance, 18) : '0'}
          unit="TOKEN"
          bgColor="bg-gradient-to-br from-purple-500 to-pink-600"
          iconColor="bg-white/20"
        />
      </div>

      {/* NFT ÊéàÊùÉ */}
      {!isApproved && (
        <InfoCard
          icon="üîê"
          title="NFT ÊéàÊùÉ"
          subtitle="ÊéàÊùÉÂ∏ÇÂú∫ÂêàÁ∫¶Êìç‰ΩúÊÇ®ÁöÑ NFT"
          iconColor="bg-gradient-to-br from-blue-500 to-indigo-600"
        >
          <ActionButton
            icon="üîì"
            label="ÊéàÊùÉ NFT"
            onClick={handleApproveNFT}
            disabled={isWritePending || isConfirming}
            loading={isWritePending || isConfirming}
            variant="primary"
          />
        </InfoCard>
      )}

      {/* Êìç‰ΩúÂå∫Âüü */}
      <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
        {/* ‰∏äÊû∂ NFT */}
        <InfoCard
          icon="üì§"
          title="‰∏äÊû∂ NFT"
          subtitle="Âá∫ÂîÆÊÇ®ÁöÑÊï∞Â≠óÊî∂ËóèÂìÅ"
          iconColor="bg-gradient-to-br from-emerald-500 to-green-600"
        >
          <div className="space-y-4">
            <InputField
              placeholder="ËæìÂÖ• NFT Token ID"
              value={tokenId}
              onChange={setTokenId}
              type="number"
            />
            
            <InputField
              placeholder="ËæìÂÖ•‰ª∑Ê†º (Token)"
              value={price}
              onChange={setPrice}
              type="number"
            />

            {/* ÊòæÁ§∫NFTÊã•ÊúâËÄÖ‰ø°ÊÅØ */}
            {tokenId && nftOwner && (
              <div className="bg-gray-50 rounded-xl p-4 space-y-3">
                <DataRow 
                  label="NFTÊã•ÊúâËÄÖ" 
                  value={`${nftOwner.slice(0, 8)}...${nftOwner.slice(-6)}`} 
                />
                <DataRow 
                  label="ÊòØÂê¶‰∏∫ÊÇ®" 
                  value={address && nftOwner.toLowerCase() === address.toLowerCase() ? "ÊòØ" : "Âê¶"} 
                  isLast
                />
              </div>
            )}
            
            {/* ÊòæÁ§∫ÂΩìÂâçÊåÇÂçï‰ø°ÊÅØ */}
            {listing && listing[0] !== '0x0000000000000000000000000000000000000000' && (
              <div className="bg-gray-50 rounded-xl p-4 space-y-3">
                <DataRow label="ÂΩìÂâçÂçñÂÆ∂" value={`${(listing[0] as string).slice(0, 8)}...${(listing[0] as string).slice(-6)}`} />
                <DataRow label="ÂΩìÂâç‰ª∑Ê†º" value={`${formatUnits(listing[1], 18)} Token`} />
                <DataRow label="Áä∂ÊÄÅ" value="Â∑≤‰∏äÊû∂" isLast />
              </div>
            )}
            
            <ActionButton
              icon="üì§"
              label={listing && listing[0] !== '0x0000000000000000000000000000000000000000' 
                     ? "Êõ¥Êñ∞‰ª∑Ê†º" : "‰∏äÊû∂ NFT"}
              onClick={handleListNFT}
              disabled={
                !tokenId || 
                !price || 
                !isApproved || 
                (nftOwner && address && nftOwner.toLowerCase() !== address.toLowerCase()) ||
                isWritePending || 
                isConfirming
              }
              loading={isWritePending || isConfirming}
              variant="primary"
            />
          </div>
        </InfoCard>

        {/* Ë¥≠‰π∞ NFT */}
        <InfoCard
          icon="üí∞"
          title="Ë¥≠‰π∞ NFT"
          subtitle="Êî∂ËóèÂøÉ‰ª™ÁöÑ‰ΩúÂìÅ"
          iconColor="bg-gradient-to-br from-purple-500 to-pink-600"
        >
          <div className="space-y-4">
            <InputField
              placeholder="ËæìÂÖ•Ë¶ÅË¥≠‰π∞ÁöÑ Token ID"
              value={buyTokenId}
              onChange={setBuyTokenId}
              type="number"
            />
            
            {/* ÊòæÁ§∫NFTÊåÇÂçï‰ø°ÊÅØ */}
            {buyListing && buyListing[0] !== '0x0000000000000000000000000000000000000000' && (
              <div className="bg-gray-50 rounded-xl p-4 space-y-3">
                <DataRow label="ÂçñÂÆ∂Âú∞ÂùÄ" value={`${(buyListing[0] as string).slice(0, 8)}...${(buyListing[0] as string).slice(-6)}`} />
                <DataRow label="NFT‰ª∑Ê†º" value={`${formatUnits(buyListing[1], 18)} Token`} />
                <DataRow label="ÊÇ®ÁöÑToken‰ΩôÈ¢ù" value={tokenBalance ? formatUnits(tokenBalance, 18) : '0'} />
                <DataRow label="ÂΩìÂâçNonce" value={tokenNonces ? tokenNonces.toString() : '0'} />
                <DataRow 
                  label="‰ΩôÈ¢ùÊòØÂê¶Ë∂≥Â§ü" 
                  value={tokenBalance && buyListing[1] && tokenBalance >= buyListing[1] ? "ÊòØ" : "Âê¶"} 
                  isLast 
                />
              </div>
            )}

            {/* Ë¥≠‰π∞ÊñπÂºèÈÄâÊã© */}
            <div className="bg-blue-50 rounded-xl p-4 space-y-3">
              <div className="text-sm font-medium text-blue-800">ÈÄâÊã©Ë¥≠‰π∞ÊñπÂºè</div>
              <div className="flex space-x-4">
                <label className="flex items-center space-x-2 cursor-pointer">
                  <input
                    type="radio"
                    checked={!usePermitBuy}
                    onChange={() => setUsePermitBuy(false)}
                    className="text-blue-600"
                  />
                  <span className="text-sm text-gray-700">Áõ¥Êé•Ë¥≠‰π∞ (ÈúÄÈ¢ÑÊéàÊùÉ)</span>
                </label>
                <label className="flex items-center space-x-2 cursor-pointer">
                  <input
                    type="radio"
                    checked={usePermitBuy}
                    onChange={() => setUsePermitBuy(true)}
                    className="text-blue-600"
                  />
                  <span className="text-sm text-gray-700">Êô∫ËÉΩË¥≠‰π∞ (‰∏ÄÈîÆÁ≠æÂêç)</span>
                </label>
              </div>
            </div>

            {/* Áõ¥Êé•Ë¥≠‰π∞ÊñπÂºè */}
            {!usePermitBuy && (
              <div className="space-y-3">
                {/* Token ÊéàÊùÉÊåâÈíÆ */}
                {buyListing && tokenAllowance && buyListing[1] > tokenAllowance && (
                  <div className="space-y-2">
                    <ActionButton
                      icon="üîì"
                      label={`ÊéàÊùÉ ${formatUnits(buyListing[1], 18)} Token`}
                      onClick={handleApproveToken}
                      disabled={isWritePending || isConfirming}
                      loading={isWritePending || isConfirming}
                      variant="secondary"
                    />
                    <ActionButton
                      icon="‚ôæÔ∏è"
                      label="Êó†ÈôêÊéàÊùÉ Token"
                      onClick={handleApproveTokenMax}
                      disabled={isWritePending || isConfirming}
                      loading={isWritePending || isConfirming}
                      variant="secondary"
                    />
                  </div>
                )}
                
                <ActionButton
                  icon="üõí"
                  label={buyListing && buyListing[0] !== '0x0000000000000000000000000000000000000000' 
                         ? `Áõ¥Êé•Ë¥≠‰π∞ (${formatUnits(buyListing[1] || BigInt(0), 18)} Token)` 
                         : "ËØ∑ËæìÂÖ• Token ID"}
                  onClick={handleDirectBuy}
                  disabled={
                    !buyTokenId || 
                    !buyListing || 
                    buyListing[0] === '0x0000000000000000000000000000000000000000' ||
                    !tokenBalance ||
                    !tokenAllowance ||
                    (buyListing[1] && tokenBalance < buyListing[1]) ||
                    (buyListing[1] && tokenAllowance < buyListing[1]) ||
                    (buyListing[0] && address && buyListing[0].toLowerCase() === address.toLowerCase()) ||
                    isWritePending ||
                    isConfirming
                  }
                  loading={isWritePending || isConfirming}
                  variant="primary"
                />
              </div>
            )}

            {/* Êô∫ËÉΩË¥≠‰π∞ÊñπÂºè (Ëá™Âä® permit) */}
            {usePermitBuy && (
              <div className="space-y-3">
                <div className="bg-green-50 rounded-xl p-4 space-y-2">
                  <div className="text-sm font-medium text-green-800">Êô∫ËÉΩË¥≠‰π∞ËØ¥Êòé</div>
                  <div className="text-xs text-green-600">
                    ‚Ä¢ Âè™ÈúÄËæìÂÖ•ÁôΩÂêçÂçïÊéàÊùÉÁ≠æÂêç<br/>
                    ‚Ä¢ Á≥ªÁªüËá™Âä®ÂÆåÊàê Token permit Á≠æÂêç<br/>
                    ‚Ä¢ ‰∏ÄÊ¨°Êìç‰ΩúÂÆåÊàêË¥≠‰π∞ÔºåÊó†ÈúÄÈ¢ÑÊéàÊùÉ
                  </div>
                </div>

                <div className="space-y-2">
                  <label className="text-sm font-medium text-gray-700">
                    ÁôΩÂêçÂçïÊéàÊùÉÁ≠æÂêç <span className="text-red-500">*</span>
                  </label>
                  <textarea
                    placeholder="Á≤òË¥¥ÂêàÁ∫¶Êã•ÊúâËÄÖÁöÑÁôΩÂêçÂçïÊéàÊùÉÁ≠æÂêç&#10;‰æãÂ¶Ç: 0x2b5322e4d270fbe08b70894e0a5a4e66f4ebbdb7..."
                    value={whitelistSignature}
                    onChange={(e) => setWhitelistSignature(e.target.value)}
                    rows={2}
                    className="w-full px-4 py-3 bg-white border border-gray-200 rounded-xl focus:ring-2 focus:ring-purple-500 focus:border-transparent transition-all duration-200 resize-none font-mono text-xs"
                  />
                  {whitelistSignature && (
                    <div className="text-xs text-gray-500">
                      Á≠æÂêçÈïøÂ∫¶: {whitelistSignature.length} Â≠óÁ¨¶
                      {whitelistSignature.length === 132 ? " ‚úÖ" : " ‚ö†Ô∏è (Â∫î‰∏∫132Â≠óÁ¨¶)"}
                    </div>
                  )}
                </div>
                
                <ActionButton
                  icon="üîê"
                  label={
                    isSigningPermit ? "Ê≠£Âú®Á≠æÂêç..." :
                    permitSignatureData ? "ÊâßË°åË¥≠‰π∞‰∏≠..." :
                    (buyListing && buyListing[0] !== '0x0000000000000000000000000000000000000000' && whitelistSignature
                     ? `Êô∫ËÉΩË¥≠‰π∞ (${formatUnits(buyListing[1] || BigInt(0), 18)} Token)` 
                     : "ËØ∑ËæìÂÖ•ÁôΩÂêçÂçïÁ≠æÂêç")
                  }
                  onClick={handlePermitBuy}
                  disabled={
                    (!buyTokenId || 
                    !buyListing || 
                    !whitelistSignature ||
                    buyListing[0] === '0x0000000000000000000000000000000000000000' ||
                    (buyListing[0] && address && buyListing[0].toLowerCase() === address.toLowerCase()) ||
                    isSigningPermit ||
                    isWritePending ||
                    isConfirming ||
                    !tokenBalance ||
                    (buyListing[1] && tokenBalance < buyListing[1])) as boolean
                  }
                  loading={isSigningPermit || isWritePending || isConfirming}
                  variant="primary"
                />

                {/* Á≠æÂêçÁä∂ÊÄÅÊèêÁ§∫ */}
                {isSigningPermit && (
                  <StatusCard
                    icon="‚úçÔ∏è"
                    title=""
                    message="ËØ∑Âú®Èí±ÂåÖ‰∏≠Á≠æÂêç Token permit ÊéàÊùÉ..."
                    type="info"
                  />
                )}

                {permitSignatureData && (
                  <StatusCard
                    icon="‚úÖ"
                    title=""
                    message="Token permit Á≠æÂêçÂÆåÊàêÔºåÊ≠£Âú®ÊâßË°åË¥≠‰π∞..."
                    type="success"
                  />
                )}
              </div>
            )}
            
            {/* Áä∂ÊÄÅÊèêÁ§∫ */}
            {buyTokenId && buyListing && buyListing[0] === '0x0000000000000000000000000000000000000000' && (
              <StatusCard
                icon="‚ùå"
                title=""
                message="Ê≠§ NFT Êú™Âú®Â∏ÇÂú∫‰∏äÊû∂"
                type="warning"
              />
            )}

            {buyListing && address && buyListing[0] && buyListing[0].toLowerCase() === address.toLowerCase() && (
              <StatusCard
                icon="‚ö†Ô∏è"
                title=""
                message="‰∏çËÉΩË¥≠‰π∞Ëá™Â∑±ÁöÑ NFT"
                type="warning"
              />
            )}

            {tokenBalance && buyListing && buyListing[1] && tokenBalance < buyListing[1] && (
              <StatusCard
                icon="üí∞"
                title=""
                message={`Token ‰ΩôÈ¢ù‰∏çË∂≥ÔºÅÈúÄË¶Å ${formatUnits(buyListing[1], 18)} Token`}
                type="warning"
              />
            )}
            
            {writeError && (
              <StatusCard
                icon="‚ùå"
                title=""
                message={`‰∫§ÊòìÂ§±Ë¥•: ${writeError.message}`}
                type="error"
              />
            )}
          </div>
        </InfoCard>
      </div>

      {/* ‰∫§ÊòìÁä∂ÊÄÅ */}
      {hash && (
        <InfoCard
          icon={isConfirmed ? "‚úÖ" : "‚è≥"}
          title={isConfirmed ? "‰∫§ÊòìÊàêÂäü" : "‰∫§ÊòìÂ§ÑÁêÜ‰∏≠"}
          subtitle={isConfirmed ? "Transaction Confirmed" : "Transaction Pending"}
          iconColor={isConfirmed ? "bg-gradient-to-br from-emerald-500 to-green-600" : "bg-gradient-to-br from-amber-500 to-yellow-600"}
        >
          <div className="space-y-2">
            <DataRow label="‰∫§ÊòìÂìàÂ∏å" value={`${hash.slice(0, 10)}...${hash.slice(-8)}`} />
            {isConfirmed && (
              <StatusCard
                icon="üéâ"
                title=""
                message="NFT ‰∫§ÊòìÊàêÂäüÂÆåÊàêÔºÅ"
                type="success"
              />
            )}
          </div>
        </InfoCard>
      )}

      {/* ÂΩìÂâçË¥¶Êà∑‰ø°ÊÅØ */}
      {address && (
        <InfoCard
          icon="üë§"
          title="ÂΩìÂâçËøûÊé•Ë¥¶Êà∑"
          subtitle="Current Connected Account"
          iconColor="bg-gradient-to-br from-indigo-500 to-purple-600"
        >
          <div className="space-y-2">
            <DataRow label="Ë¥¶Êà∑Âú∞ÂùÄ" value={`${address.slice(0, 8)}...${address.slice(-6)}`} />
            <DataRow label="Token Nonce" value={tokenNonces ? tokenNonces.toString() : '0'} />
            <DataRow label="ÁîüÊàêÁôΩÂêçÂçïÁ≠æÂêç" value={`./signature.sh ${address}`} isLast />
          </div>
        </InfoCard>
      )}
    </PageContainer>
  );
}
